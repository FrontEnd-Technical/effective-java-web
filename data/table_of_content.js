export const index_menu = [
  {
    title: "1 Introduction",
    items: [],
  },
  {
    title: "2 Creating and Destroying Objects",
    items: [
      {
        title:
          "Item 1: Consider static factory methods instead of constructors",
        path: "/articles/item1",
      },
      {
        title:
          "Item 2: Consider a builder when faced with many constructor parameters",
        path: "/articles/item2",
      },
      {
        title:
          "Item 3: Enforce the singleton property with a private constructor or an enum type",
        path: "/articles/item3",
      },
      {
        title: "Item 4: Enforce noninstantiability with a private constructor",
        path: "/articles/item4",
      },
      {
        title: "Item 5: Prefer dependency injection to hardwiring resources",
        path: "/articles/item5",
      },
      {
        title: "Item 6: Avoid creating unnecessary objects",
        path: "/articles/item6",
      },
      {
        title: "Item 7: Eliminate obsolete object references",
        path: "/articles/item7",
      },
      {
        title: "Item 8: Avoid finalizers and cleaners",
        path: "/articles/item8",
      },
      {
        title: "Item 9: Prefer try-with-resources to try-finally",
        path: "/articles/item9",
      },
    ],
  },
  {
    title: "3 Methods Common to All Objects",
    items: [
      {
        title: "Item 10: Obey the general contract when overriding equals",
        path: "/articles/item10",
      },
      {
        title: "Item 11: Always override hashCode when you override equals",
        path: "/articles/item11",
      },
      {
        title: "Item 12: Always override toString",
        path: "/articles/item12",
      },
      {
        title: "Item 13: Override clone judiciously",
        path: "/articles/item13",
      },
      {
        title: "Item 14: Consider implementing Comparable",
        path: "/articles/item14",
      },
    ],
  },
  {
    title: "4 Classes and Interfaces",
    items: [
      {
        title: "Item 15: Minimize the accessibility of classes and members",
        path: "/articles/item15",
      },
      {
        title:
          "Item 16: In public classes, use accessor methods, not public fields",
        path: "/articles/item16",
      },
      { title: "Item 17: Minimize mutability", path: "/articles/item17" },
      {
        title: "Item 18: Favor composition over inheritance",
        path: "/articles/item18",
      },
      {
        title:
          "Item 19: Design and document for inheritance or else prohibit it",
        path: "/articles/item19",
      },
      {
        title: "Item 20: Prefer interfaces to abstract classes",
        path: "/articles/item20",
      },
      {
        title: "Item 21: Design interfaces for posterity",
        path: "/articles/item21",
      },
      {
        title: "Item 22: Use interfaces only to define types",
        path: "/articles/item22",
      },
      {
        title: "Item 23: Prefer class hierarchies to tagged classes",
        path: "/articles/item23",
      },
      {
        title: "Item 24: Favor static member classes over nonstatic",
        path: "/articles/item24",
      },
      {
        title: "Item 25: Limit source files to a single top-level class",
        path: "/articles/item25",
      },
    ],
  },
];
